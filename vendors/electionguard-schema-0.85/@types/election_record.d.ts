/* tslint:disable */
/**
 * This file was automatically generated by json-schema-to-typescript.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run json-schema-to-typescript to regenerate this file.
 */

/**
 * The safe prime modulus `p`
 */
export type BigUint = string | number;
/**
 * The generator `g` of the multiplicative subgroup `Z^*_q`, where `p = 2q + 1`.
 */
export type BigNaturalNumber = string | number;
/**
 * An ElGamal public key.
 */
export type BigNaturalNumber1 = string | number;
/**
 * The one-use public key `k = gʳ` generated from the random one-use private key `r`. This acts as a committment to `r`.
 */
export type BigNaturalNumber2 = string | number;
/**
 * The challenge `c` that is produced by hashing relevent parameters, including the original public key `h` and the one-time public key `k`.
 */
export type BigUint1 = string | number;
/**
 * The response `u = r + c s mod (p - 1)` to the challenge, where `r` is the one-time private key corresponding to the one-time public key `k`, and `s` is the private-key corresponding to the original public key `h`.
 */
export type BigUint2 = string | number;
/**
 * The election public key `K`.
 */
export type BigNaturalNumber3 = string | number;
/**
 * The one-time public key `a = gʳ`, where `r` is the randomly generated one-time public key.
 */
export type BigNaturalNumber4 = string | number;
/**
 * The encoding `b = gᵐ hʳ`, where `m` is the cleartext and `h` is the recipient public key being used for encryption.
 */
export type BigNaturalNumber5 = string | number;
/**
 * The challenge value `c` that is produced by hashing relevent parameters, including the original ElGamal message `(a,b)` and the zero message `(α, β)`.
 */
export type BigUint3 = string | number;
/**
 * The response `u = t + c r mod (p-1)` to the challenge `c`, where `r` is the one-time private key used to encrypt the original message and `t` is the one-time private key used to encrypt the zero message used in this proof.
 */
export type BigUint4 = string | number;
/**
 * The decrypted message of the selection.
 */
export type BigNaturalNumber6 = string | number;
/**
 * The share of the decrypted message `M_i`.
 */
export type BigUint5 = string | number;
/**
 * The actual fragment `M_{i,j}` which is trustee `j`'s piece of the missing trustee `i`'s share of a decryption.
 */
export type BigNaturalNumber7 = string | number;
/**
 * The LaGrange coefficient `w_{i,j}` used to compute the decryption share from the fragments.
 */
export type BigUint6 = string | number;
/**
 * The decrypted tally `M`.
 */
export type BigNaturalNumber8 = string | number;

/**
 * All data from an ElectionGuard election.
 */
export interface ElectionRecord {
  parameters: ElectionParameters;
  /**
   * The base hash `Q` which is a SHA-256 hash of eleciton parameters including the prime modulus, generator, number of trustees, decryption threshold value, date, and jurisdictional information, as well as the contest configurations.
   */
  base_hash: string;
  /**
   * The public keys/coefficient commitments for each trustee.
   */
  trustee_public_keys: [
    [
      {
        public_key: BigNaturalNumber1;
        proof: SchnorrProof;
        [k: string]: any;
      },
      ...({
        public_key: BigNaturalNumber1;
        proof: SchnorrProof;
        [k: string]: any;
      })[]
    ],
    ...([
      {
        public_key: BigNaturalNumber1;
        proof: SchnorrProof;
        [k: string]: any;
      },
      ...({
        public_key: BigNaturalNumber1;
        proof: SchnorrProof;
        [k: string]: any;
      })[]
    ])[]
  ];
  joint_public_key: BigNaturalNumber3;
  /**
   * The extended base hash `Q̅`.
   */
  extended_base_hash: string;
  /**
   * The encrypted ballots cast in the election.
   */
  cast_ballots: EncryptedBallot[];
  /**
   * The decryptions of the ballots spoiled in the election, including their encrypted selections, their decrypted selections, the cleartext of each selection, and proofs of the correctness of the decryptions.
   */
  spoiled_ballots: BallotDecryption[];
  /**
   * The decryptions of the tallies of each option for each contests in the election.
   */
  contest_tallies: [[TallyDecryption, ...(TallyDecryption)[]], ...([TallyDecryption, ...(TallyDecryption)[]])[]];
  [k: string]: any;
}
/**
 * All the parameters necessary to form the election.
 */
export interface ElectionParameters {
  /**
   * The date on which the election takes place.
   */
  date: string;
  /**
   * The location where the election takes place
   */
  location: string;
  /**
   * The configuration file used in the election.
   */
  ballotCodingFile?: {
    ballotStyles: {
      districts: string[];
      id: string;
      partyId?: string;
      precincts: string[];
      [k: string]: any;
    }[];
    bmdConfig?: {
      requireActivation?: boolean;
      showHelpPage?: boolean;
      showSettingsPage?: boolean;
      [k: string]: any;
    };
    contests: (
      | {
          allowWriteIns: boolean;
          candidates: {
            id: string;
            isWriteIn?: boolean;
            name: string;
            partyId?: string;
            [k: string]: any;
          }[];
          districtId: string;
          id: string;
          partyId?: string;
          seats: number;
          section: string;
          title: string;
          type: "candidate";
          [k: string]: any;
        }
      | {
          description: string;
          districtId: string;
          id: string;
          partyId?: string;
          section: string;
          shortTitle: string;
          title: string;
          type: "yesno";
          [k: string]: any;
        })[];
    county: {
      id: string;
      name: string;
      [k: string]: any;
    };
    date: string;
    districts: {
      id: string;
      name: string;
      [k: string]: any;
    }[];
    parties: {
      abbrev: string;
      id: string;
      name: string;
      [k: string]: any;
    }[];
    precincts: {
      id: string;
      name: string;
      [k: string]: any;
    }[];
    seal?: string;
    sealURL?: string;
    state: string;
    title: string;
    [k: string]: any;
  };
  prime: BigUint;
  generator: BigNaturalNumber;
  /**
   * The number of election trustees `n`.
   */
  num_trustees: number;
  /**
   * The threshold `k` of trustees required to complete verification.
   */
  threshold: number;
  [k: string]: any;
}
/**
 * A proof of posession of the private key.
 */
export interface SchnorrProof {
  commitment: BigNaturalNumber2;
  challenge: BigUint1;
  response: BigUint2;
  [k: string]: any;
}
/**
 * An encrypted ballot, consisting of the encrypted selections for each contest, their proofs of well-formedness, and information about where and when the ballot was encrypted.
 */
export interface EncryptedBallot {
  contests: {
    /**
     * The encrypted selections made on the ballot.
     */
    selections: {
      message: ElGamalMessage;
      zero_proof: ChaumPedersenProof;
      one_proof: ChaumPedersenProof;
      [k: string]: any;
    }[];
    /**
     * The maximum number of selections `L` that can be made in this contest.
     */
    max_selections: number;
    num_selections_proof: ChaumPedersenProof1;
    [k: string]: any;
  }[];
  ballot_info: BallotInformation;
  [k: string]: any;
}
/**
 * A message that has been encrypted using exponential ElGamal.
 */
export interface ElGamalMessage {
  public_key: BigNaturalNumber4;
  ciphertext: BigNaturalNumber5;
  [k: string]: any;
}
/**
 * A non-interactive zero-knowledge Chaum-Pedersen proof shows that an ElGamal message `(a,b) = (gʳ, gᵐ hʳ)` is actually an encryption of zero (`m = 0`) without revealing the nonce `r` used to encode it. This can be used to show that two ElGamal messages encrypt the same message, by creating a Chaum-Pedersen proof for their quotient `(a₁/a₂, b₁/b₂) = (gʳ¹⁻ʳ², gᵐ¹⁻ᵐ² hʳ¹⁻ʳ²)`.
 */
export interface ChaumPedersenProof {
  commitment: ElGamalMessage1;
  challenge: BigUint3;
  response: BigUint4;
  [k: string]: any;
}
/**
 * An ElGamal message `(α, β)` encoding zero. This is useful because you can only combine two ciphertexts if they both encode zero, as in the equation `hᵘ = hᵗ⁺ᶜʳ = hᵗ (hʳ)ᶜ = β bᶜ`. This acts as a commitment to the one-time private key `t` used in this proof.
 */
export interface ElGamalMessage1 {
  public_key: BigNaturalNumber4;
  ciphertext: BigNaturalNumber5;
  [k: string]: any;
}
/**
 * A proof that the sum of the selections is equal to `L`, by proving that their difference is zero.
 */
export interface ChaumPedersenProof1 {
  commitment: ElGamalMessage1;
  challenge: BigUint3;
  response: BigUint4;
  [k: string]: any;
}
/**
 * Auxiliary information about a ballot other than the selections made by the voter.
 */
export interface BallotInformation {
  /**
   * Information about the device that encrypted the ballot
   */
  device_info: string;
  /**
   * The date the ballot was encrypted.
   */
  date: string;
  /**
   * The time the ballot was encrypted.
   */
  time: string;
  /**
   * The tracker code generated for this ballot.
   */
  tracker: string;
  [k: string]: any;
}
/**
 * A decryption of an encrypted ballot that was spoiled.
 */
export interface BallotDecryption {
  contests: {
    encrypted_message: ElGamalMessage2;
    decrypted_message: BigNaturalNumber6;
    /**
     * The decryption shares `M_i` used to compute the decryption `M`.
     */
    shares: DecryptionShare[];
    /**
     * The actual value encrypted, so either a zero or a one.
     */
    cleartext: number;
    [k: string]: any;
  }[][];
  ballot_info: BallotInformation;
  [k: string]: any;
}
/**
 * The encrypted message of the selection (the one or zero).
 */
export interface ElGamalMessage2 {
  public_key: BigNaturalNumber4;
  ciphertext: BigNaturalNumber5;
  [k: string]: any;
}
/**
 * A single trustee's share of a decryption of some encrypted message `(a, b)`. The encrypted message can be an encrypted tally or an encrypted ballot.
 */
export interface DecryptionShare {
  share: BigUint5;
  proof: ChaumPedersenProof2;
  /**
   * The `k` fragments used to reconstruct this decryption share, if this trustee was absent.
   */
  fragments?: {
    /**
     * The index of the trustee who produced this fragment.
     */
    trustee_index: number;
    fragment: BigNaturalNumber7;
    lagrange_coefficient: BigUint6;
    proof: ChaumPedersenProof3;
    [k: string]: any;
  }[];
  [k: string]: any;
}
/**
 * The proof that the share encodes the same value as the encrypted message.
 */
export interface ChaumPedersenProof2 {
  commitment: ElGamalMessage1;
  challenge: BigUint3;
  response: BigUint4;
  [k: string]: any;
}
/**
 * The proof that the fragment encodes the same values as the encrypted message
 */
export interface ChaumPedersenProof3 {
  commitment: ElGamalMessage1;
  challenge: BigUint3;
  response: BigUint4;
  [k: string]: any;
}
/**
 * A decryption of the encrypted tally of a single option in a contest.
 */
export interface TallyDecryption {
  encrypted_tally: ElGamalMessage;
  decrypted_tally: BigNaturalNumber8;
  /**
   * The decryption shares `M_i` used to compute the decrypted tally `M`.
   */
  shares: DecryptionShare[];
  /**
   * The actual tally encrypted.
   */
  cleartext: number;
  [k: string]: any;
}
